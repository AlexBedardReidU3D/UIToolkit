using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using Attributes;
using UnityEngine;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;
using Button = Attributes.Button;

namespace Editor.Utilities.FileWriters
{
    //TODO Take a look here: https://docs.unity3d.com/Manual/roslyn-analyzers.html
    public static class UXMLGenerator
    {
        private static readonly string PATH = Path.Combine(Application.dataPath, "Editor", "Custom Inspectors");
        
        public enum UITYPE
        {
            UI,
            UIE
        }
        
        //Structs
        //================================================================================================================//
        
        private readonly struct TypeAttributes
        {
            public readonly Type myType;
            public readonly IEnumerable<Attribute> myAttributes;

            public TypeAttributes(in Type type, in IEnumerable<GenerateUXML> attributes)
            {
                myType = type;
                myAttributes = attributes;
            }
            
        }
        
        private class MemberGroupInfo
        {
            public GroupsBase GroupsBase;
            public List<object> Objects;
        }
        
        //Static Properties
        //================================================================================================================//

        private static Dictionary<Type, List<MethodInfo>> s_ButtonFunctions;
       
        //================================================================================================================//

        [UnityEditor.Callbacks.DidReloadScripts]
        private static void OnScriptsReloaded() 
        {
            //----------------------------------------------------------//

            TypeAttributes[] GetTypeAttributes()
            {
                return (from a in AppDomain.CurrentDomain.GetAssemblies()
                    from t in a.GetTypes()
                    let attributes = t.GetCustomAttributes(typeof(GenerateUXML), true)
                    where attributes != null && attributes.Length > 0
                    select new TypeAttributes(t, attributes.Cast<GenerateUXML>())).ToArray();
            }
            
            //----------------------------------------------------------//

            //Based on: https://stackoverflow.com/a/607204
            var typesWithGenerateUxml = GetTypeAttributes();

            s_ButtonFunctions = new Dictionary<Type, List<MethodInfo>>();

            for (int i = 0; i < typesWithGenerateUxml.Length; i++)
            {
                var type = typesWithGenerateUxml[i].myType;
                
                s_ButtonFunctions.Add(type, new List<MethodInfo>());
                
                TryCreateUxmlFile(type);
                ScriptGenerator.TryCreateCustomEditor(type, s_ButtonFunctions[type]);
            }

            AssetDatabase.Refresh();
        }

        private static void TryCreateUxmlFile(in Type type)
        {
            DirectoryInfo directoryInfo = new DirectoryInfo(Path.Combine(Application.dataPath, "Editor", "Custom Inspectors", type.Name));
            
            if(directoryInfo.Exists == false)
                directoryInfo.Create();
            
            var filePath = Path.Combine(PATH, type.Name, $"{type.Name}UXML.uxml");
            File.WriteAllText(filePath, GetUXMLCode(type));
            
            Debug.Log($"Successfully Generated UXML for {type.Name}");
        }
        
        //Generate UXML
        //================================================================================================================//

        private static string GetUXMLCode(in Type type)
        {
            var writer = new UXMLWriter
            {
                buffer = new StringBuilder()
            };

            //Write Header
            writer.WriteLine(WriterHelper.MakeAutoGeneratedCodeXMLHeader(
                "UXML Generator",
                new Version(0,0,1).ToString(),
                nameof(UXMLGenerator)));
            
            writer.WriteLine();
            
            //Write UXML starter
            writer.WriteLine("<ui:UXML xmlns:ui=\"UnityEngine.UIElements\" xmlns:uie=\"UnityEditor.UIElements\" editor-extension-mode=\"True\">");
            writer.BeginBlock();
            //Add custom Style Sheet
            writer.WriteLine("<Style src=\"project://database/Assets/Editor/Prototyping/NewUSSFile.uss?fileID=7433441132597879392&amp;guid=6900da3c74504df48882b65fbc801786&amp;type=3#NewUSSFile\" />");
            //Get type members that are not constructors, ordered by their metadata token
            var memberInfos = type.GetMembers(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public)
                .Where(x => (x is ConstructorInfo) == false)
                .OrderBy(x => x.MetadataToken)
                .ToArray();

            //Group members together by the specified header name
            var groupedMembers = TryGetGroupedMembers(memberInfos);
            
            for (var i = 0; i < groupedMembers.Count; i++)
            {
                switch (groupedMembers[i])
                {
                    case MemberGroupInfo memberGroupInfo:
                        GetGroupUXML(type, ref writer, memberGroupInfo);
                        break;
                    case FieldInfo fieldInfo:
                        if(fieldInfo.IsPrivate && fieldInfo.GetCustomAttributes(typeof(SerializeField), false).Length == 0)
                            continue;
                        //Write fields
                        GetFieldAsUXML(ref writer, fieldInfo);
                        break;
                    case MethodInfo methodInfo:
                        GetMethodAsUxml(type, methodInfo, ref writer);
                        break;
                }
            }

            //End Field Block
            writer.EndBlock();
            
            //Close File
            writer.WriteLine("</ui:UXML>");

            return writer.buffer.ToString();
        }

        private static void GetFieldAsUXML(ref UXMLWriter writer, in FieldInfo fieldInfo)
        {
            var infoBox = fieldInfo.GetCustomAttribute<InfoBox>();
            var customLabel = fieldInfo.GetCustomAttribute<CustomLabel>();
            var readOnly = fieldInfo.GetCustomAttribute<ReadOnly>() != null;
            var displayAsString = fieldInfo.GetCustomAttribute<DisplayAsString>() != null;

            var label = customLabel != null ? customLabel.GetText() : fieldInfo.Name;

            if (infoBox != null)
            {
                AddInfoBox(ref writer, infoBox);
            }

            //Display As String
            //----------------------------------------------------------//

            if (displayAsString)
            {
                DisplayAsString(ref writer, label, fieldInfo);
                return;
            }

            var hasCustomEditor = fieldInfo.FieldType.HasCustomEditor();

            //Custom Editor Drawer, for non-unity objects
            //----------------------------------------------------------//
            if(hasCustomEditor && fieldInfo.FieldType.IsSubclassOf(typeof(UnityEngine.Object)) == false)
            {
                BeginFoldoutGroup(ref writer, label);
                //writer.WriteLine($"<uie:PropertyField binding-path=\"{fieldInfo.Name}\" label=\"{label}\" />");
                ElementBuilder(ref writer, UITYPE.UIE, "PropertyField", label:label, bindingPath:fieldInfo.Name, isReadonly: readOnly);

                EndFoldoutGroup(ref writer);
                return;
            }


            //String field element
            //----------------------------------------------------------//
            
            if (fieldInfo.FieldType == typeof(System.String))
            {
                //writer.WriteLine($"<ui:TextField picking-mode=\"Ignore\" label=\"{label}\" binding-path=\"{fieldInfo.Name}\" />");
                ElementBuilder(ref writer, UITYPE.UI, "TextField", label:label, bindingPath:fieldInfo.Name, pickingMode: "ignore", isReadonly: readOnly);

                return;
            }
            
            //Class Drawing
            //----------------------------------------------------------//
            if (fieldInfo.FieldType.IsClass)
            {
                switch (fieldInfo.FieldType.Namespace)
                {
                    case "UnityEngine":
                        //writer.WriteLine( $"<uie:ObjectField binding-path=\"{fieldInfo.Name}\" label=\"{label}\" type=\"{fieldInfo.FieldType.FullName}, UnityEngine.CoreModule\" {GetReadonlyString(readOnly)}/>");
                        ElementBuilder(ref writer, UITYPE.UIE, "ObjectField", label:label, bindingPath:fieldInfo.Name, types: new []
                        {
                            fieldInfo.FieldType.FullName,
                            "UnityEngine.CoreModule"
                        }, isReadonly: readOnly);

                        return;
                    default:
                        //writer.WriteLine($"<uie:PropertyField binding-path=\"{fieldInfo.Name}\" label=\"{label}\" />");
                        ElementBuilder(ref writer, UITYPE.UIE, "PropertyField", label:label, bindingPath:fieldInfo.Name, isReadonly: readOnly);

                        return;
                }
            }
            //Value Type
            //----------------------------------------------------------//

            string uieType;
            switch (fieldInfo.FieldType.Name)
            {
                case nameof(Int32):
                    uieType = "IntegerField";
                    break;
                case nameof(Single):
                    uieType = "FloatField";
                    break;
                case nameof(Int64):
                    uieType = "LongField";
                    break;
                case nameof(Vector2):
                case nameof(Vector3):
                case nameof(Vector4):
                case nameof(Rect):
                case nameof(Bounds):
                case nameof(Vector2Int):
                case nameof(Vector3Int):
                    uieType = $"{fieldInfo.FieldType.Name}Field";
                    break;
                default:
                    //writer.WriteLine($"<uie:PropertyField binding-path=\"{fieldInfo.Name}\" label=\"{label}\" />");
                    ElementBuilder(ref writer, UITYPE.UIE, "PropertyField", label:label, bindingPath:fieldInfo.Name, isReadonly: readOnly);
                    return;
                
            }

            //Default Return
            //----------------------------------------------------------//

            //writer.WriteLine($"<uie:{uieType} label=\"{label}\" value=\"\" binding-path=\"{fieldInfo.Name}\" {GetReadonlyString(readOnly)} />");
            ElementBuilder(ref writer, UITYPE.UIE, uieType, label:label, value:string.Empty, bindingPath:fieldInfo.Name, isReadonly: readOnly);
        }

        

        private static void GetMethodAsUxml(in Type type, in MethodInfo methodInfo, ref UXMLWriter writer)
        {
            var button = methodInfo.GetCustomAttribute<Button>();

            if (button == null)
                return;
            
            var infoBox = methodInfo.GetCustomAttribute<InfoBox>();
            if (infoBox != null)
            {
                AddInfoBox(ref writer, infoBox);
            }

            s_ButtonFunctions[type].Add(methodInfo);

            var buttonText = button.GetText();

            var label = string.IsNullOrEmpty(buttonText) ? methodInfo.Name : buttonText;
            
            //FIXME Binding Path gets a string for the label, and is not the call for the method
            //writer.WriteLine($"<ui:Button name=\"{methodInfo.Name}\" text=\"{label}\" display-tooltip-when-elided=\"true\" />");

            ElementBuilder(ref writer, UITYPE.UI, "Button", name: methodInfo.Name, text: label, elidedTooltip: true);
        }

        //UXML Group Functions
        //================================================================================================================//

        private static List<object> TryGetGroupedMembers(MemberInfo[] memberInfos)
        {
            var outList = new List<object>();
            var groupKeys = new Dictionary<string, MemberGroupInfo>();
            //var groupedMembers = new Dictionary<GroupsBase, List<object>>();
            
            for (int i = 0; i < memberInfos.Length; i++)
            {
                //Don't want to store the constructor
                if(memberInfos[i] is ConstructorInfo)
                    continue;
                
                //Check to see if we want to use a group for this member
                var groupsBase = memberInfos[i].GetCustomAttribute<GroupsBase>();

                //If there's no group, store it so we can retain the order
                if (groupsBase == null)
                {
                    outList.Add(memberInfos[i]);
                    continue;
                }

                //Look at the groups path, to see if it's a sub-group
                var groups = groupsBase.GetPath().Split('/');

                //FIXME For not, we are ignoring the sub-groups, as they still needs to be designed
                if (groups.Length > 1)
                {
                    //TODO Go through each layer
                    throw new NotImplementedException("Layered groups are not yet supported");
                }
                else
                {
                    //Get the group name, this is used to group elements together
                    var groupName = groupsBase.GetName();
                    
                    //See if we've already created the group, if not we'll have to add it
                    if (groupKeys.TryGetValue(groupName, out var foundGroup) == false)
                    {
                        var groupData = new MemberGroupInfo
                        {
                            GroupsBase = groupsBase,
                            Objects = new List<object>
                            {
                                memberInfos[i]
                            }
                        };
                        
                        groupKeys.Add(groupName, groupData);
                        outList.Add(groupData);
                    }
                    else
                    {
                        if (groupsBase.GetType() != foundGroup.GroupsBase.GetType())
                        {
                            throw new Exception($"Group {groupName} Cannot use {groupsBase.GetType()} as it already exists as {foundGroup.GroupsBase.GetType()}");
                        }

                        foundGroup.Objects.Add(memberInfos[i]);
                    }

                }
                
            }

            return outList;
        }

        private static void GetGroupUXML(in Type type, ref UXMLWriter writer, in MemberGroupInfo memberGroupInfo)
        {
            BeginGroup(memberGroupInfo.GroupsBase, ref writer);
            foreach (var memberObject in memberGroupInfo.Objects)
            {
                switch (memberObject)
                {
                    case FieldInfo fieldInfo:
                        if(fieldInfo.IsPrivate && fieldInfo.GetCustomAttributes(typeof(SerializeField), false).Length == 0)
                            continue;
                        //Write fields
                        GetFieldAsUXML(ref writer, fieldInfo);
                        break;
                    case MethodInfo methodInfo:
                        GetMethodAsUxml(type, methodInfo, ref writer);
                        break;
                    case MemberGroupInfo _:
                        throw new NotImplementedException("Sub groups are not yet supported");
                    default:
                        throw new ArgumentOutOfRangeException(nameof(memberObject), memberObject, null);
                }
            }
            EndGroup(memberGroupInfo.GroupsBase, ref writer);
        }

        private static void BeginGroup(in GroupsBase groupsBase, ref UXMLWriter writer)
        {
            string CheckHasBindingPath(in string label)
            {
                if (label[0].Equals('$') == false)
                    return $"text=\"{label}\"";
                
                return $"text=\"1\" binding-path=\"{label.Remove(0, 1)}\"";
            }
            switch (groupsBase)
            {
                case VerticalLayoutGroup _:
                    writer.WriteLine($"<ui:GroupBox name=\"{groupsBase.GetName()}\">");
                    break;
                case HorizontalLayoutGroup _:
                    writer.WriteLine($"<ui:GroupBox name=\"{groupsBase.GetName()}\" style=\"flex-direction: row; justify-content: space-around;\" />");
                    break;
                case TitleGroup titleGroup:
                    writer.WriteLine($"<ui:GroupBox name=\"{groupsBase.GetName()}\" {CheckHasBindingPath(titleGroup.GetLabel())} class=\"title-group\">");
                    break;
                case FoldoutGroup foldoutGroup:
                    writer.WriteLine($"<ui:Foldout name=\"{groupsBase.GetName()}\" {CheckHasBindingPath(foldoutGroup.GetLabel())} value=\"true\" class=\"foldout-group\">");
                    break;
                case BoxGroup boxGroup:
                    writer.WriteLine($"<ui:GroupBox name=\"{groupsBase.GetName()}\" {CheckHasBindingPath(boxGroup.GetLabel())} class=\"box-group\">");
                    break;
                default:
                    throw new NotImplementedException();
            }
            
            writer.BeginBlock();

        }
        private static void EndGroup(in GroupsBase groupsBase, ref UXMLWriter writer)
        {
            writer.EndBlock();
            switch (groupsBase)
            {
                case VerticalLayoutGroup _:
                case HorizontalLayoutGroup _:
                case TitleGroup _:
                case BoxGroup _:
                    writer.WriteLine("</ui:GroupBox>");
                    break;
                case FoldoutGroup _ :
                    writer.WriteLine("</ui:Foldout>");
                    break;
                default:
                    throw new NotImplementedException();
            }
        }
        
        //================================================================================================================//

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void AddInfoBox(ref UXMLWriter writer, in InfoBox infoBox)
        {
            writer.WriteLine("<ui:GroupBox class=\"info-box\">");
            writer.BeginBlock();
            writer.WriteLine("<ui:VisualElement />");
            writer.WriteLine($"<ui:Label text=\"{infoBox.InfoText}\" display-tooltip-when-elided=\"true\" />");
            writer.EndBlock();
            writer.WriteLine("</ui:GroupBox>");
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void BeginFoldoutGroup(ref UXMLWriter writer, in string text)
        {
            writer.WriteLine($"<ui:Foldout text=\"{text}\">");
            writer.BeginBlock();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void EndFoldoutGroup(ref UXMLWriter writer)
        {
            writer.EndBlock();
            writer.WriteLine("</ui:Foldout>");
        }

        private static void DisplayAsString(ref UXMLWriter writer, in string label, in FieldInfo fieldInfo)
        {
            //Example of a horizontal layout group used with 2 labels
            /*
                <ui:GroupBox style="justify-content: flex-start; flex-direction: row; align-items: auto;">
                    <ui:Label text="Label" display-tooltip-when-elided="true" />
                    <ui:Label text="Label" display-tooltip-when-elided="true" />
                </ui:GroupBox>
             */
            writer.WriteLine("<ui:GroupBox class=\"display-as-string\">");
                writer.BeginBlock();
                ElementBuilder(ref writer, UITYPE.UI, "Label", text:label, elidedTooltip:true);
                ElementBuilder(ref writer, UITYPE.UI, "Label", text:string.Empty, bindingPath:fieldInfo.Name, elidedTooltip:true);
                //writer.WriteLine($"<ui:Label text=\"{label}\" display-tooltip-when-elided=\"true\" />");
                //writer.WriteLine($"<ui:Label text=\"\" binding-path=\"{fieldInfo.Name}\" display-tooltip-when-elided=\"true\" />");
                writer.EndBlock();
            writer.WriteLine("</ui:GroupBox>");
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static string GetReadonlyString(in bool readOnly)
        {
            return (readOnly ? "focusable=\"false\" readonly=\"true\" style=\"opacity: 0.5;\"" : string.Empty);
        }
        
        //================================================================================================================//

        private static void ElementBuilder(ref UXMLWriter uxmlWriter, 
            in UITYPE uiType, 
            in string fieldType,
            in string name = null,
            in string label = null,
            in string text = null,
            in string value = null,
            in string bindingPath = null,
            in string[] types = null,
            in string pickingMode = null,
            in string style = null,
            in string[] classes = null,
            in bool isReadonly = false,
            in bool elidedTooltip = false)
        {
            var assembly = new List<string>
            {
                fieldType
            };
            if(name != null)
                assembly.Add($"name=\"{name}\"");
            if(label != null)
                assembly.Add($"label=\"{label}\"");
            if(text != null)
                assembly.Add($"text=\"{text}\"");
            if(value != null)
                assembly.Add($"value=\"{value}\"");
            if(bindingPath != null)
                assembly.Add($"binding-path=\"{bindingPath}\"");
            if(types != null && types.Length > 0)
                assembly.Add($"type=\"{string.Join(", ", types)}\"");
            if(pickingMode != null)
                assembly.Add($"pickingMode=\"{pickingMode}\"");
            if(classes != null && classes.Length > 0)
                assembly.Add($"class=\"{string.Join(' ', classes)}\"");
            if(style != null)
                assembly.Add($"style=\"{style}\"");
            if(isReadonly)
                assembly.Add(GetReadonlyString(true));
            if(elidedTooltip)
                assembly.Add("display-tooltip-when-elided=\"true\"");

            uxmlWriter.WriteLine($"<{uiType.GetAsString()}:{string.Join(' ', assembly)}/>");
        }

        
    }
}