using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using UnityEngine;
using UnityEditor;

namespace Editor.Utilities.FileWriters
{
    //TODO Take a look here: https://docs.unity3d.com/Manual/roslyn-analyzers.html
    public static class UXMLGenerator
    {
        private static readonly string PATH = Path.Combine(Application.dataPath, "Editor", "Custom Inspectors");
        
        //Go Through Classes looking for GenerateUXML
        //================================================================================================================//
        
        private readonly struct TypeAttributes
        {
            public readonly Type myType;
            public readonly IEnumerable<Attribute> myAttributes;

            public TypeAttributes(in Type type, in IEnumerable<GenerateUXML> attributes)
            {
                myType = type;
                myAttributes = attributes;
            }
            
        }

        private static Dictionary<Type, List<MethodInfo>> s_ButtonFunctions;

        [UnityEditor.Callbacks.DidReloadScripts]
        private static void OnScriptsReloaded() 
        {
            //----------------------------------------------------------//

            TypeAttributes[] GetTypeAttributes()
            {
                return (from a in AppDomain.CurrentDomain.GetAssemblies()
                    from t in a.GetTypes()
                    let attributes = t.GetCustomAttributes(typeof(GenerateUXML), true)
                    where attributes != null && attributes.Length > 0
                    select new TypeAttributes(t, attributes.Cast<GenerateUXML>())).ToArray();
            }
            
            //----------------------------------------------------------//

            //Based on: https://stackoverflow.com/a/607204
            var typesWithGenerateUxml = GetTypeAttributes();

            s_ButtonFunctions = new Dictionary<Type, List<MethodInfo>>();

            for (int i = 0; i < typesWithGenerateUxml.Length; i++)
            {
                var type = typesWithGenerateUxml[i].myType;
                
                s_ButtonFunctions.Add(type, new List<MethodInfo>());
                
                TryCreateUxmlFile(type);
                ScriptGenerator.TryCreateCustomEditor(type, s_ButtonFunctions[type]);
            }

            AssetDatabase.Refresh();
        }

        private static void TryCreateUxmlFile(in Type type)
        {
            DirectoryInfo directoryInfo = new DirectoryInfo(Path.Combine(Application.dataPath, "Editor", "Custom Inspectors", type.Name));
            
            if(directoryInfo.Exists == false)
                directoryInfo.Create();
            
            var filePath = Path.Combine(PATH, type.Name, $"{type.Name}UXML.uxml");
            File.WriteAllText(filePath, GetUXMLCode(type));
            
            Debug.Log($"Successfully Generated UXML for {type.Name}");
        }
        
        
        //Generate UXML
        //================================================================================================================//

        private static string GetUXMLCode(in Type type)
        {
            var writer = new UXMLWriter
            {
                buffer = new StringBuilder()
            };

            //Write Header
            writer.WriteLine(WriterHelper.MakeAutoGeneratedCodeXMLHeader(
                "UXML Generator",
                new Version(0,0,1).ToString(),
                nameof(UXMLGenerator)));
            
            writer.WriteLine();
            
            //Write UXML starter
            writer.WriteLine("<ui:UXML xmlns:ui=\"UnityEngine.UIElements\" xmlns:uie=\"UnityEditor.UIElements\" editor-extension-mode=\"True\">");
            writer.BeginBlock();
            
            var memberInfos = type.GetMembers(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            memberInfos = memberInfos
                .OrderBy(x => x.MetadataToken)
                .ToArray();
            
            for (int i = 0; i < memberInfos.Length; i++)
            {
                switch (memberInfos[i])
                {
                    case ConstructorInfo _:
                        continue;
                    case FieldInfo fieldInfo:
                        if(fieldInfo.IsPrivate && fieldInfo.GetCustomAttributes(typeof(SerializeField), false).Length == 0)
                            continue;
                        //Write fields
                        GetFieldAsUXML(writer, fieldInfo);
                        break;
                    case MethodInfo methodInfo:
                        GetMethodAsUxml(type, methodInfo, ref writer);
                        break;
                }
            }

            //End Field Block
            writer.EndBlock();
            
            //Close File
            writer.WriteLine("</ui:UXML>");

            return writer.buffer.ToString();
        }

        private static void GetFieldAsUXML(UXMLWriter writer, in FieldInfo fieldInfo)
        {
            var customLabel = fieldInfo.GetCustomAttribute<CustomLabel>();
            var readOnly = fieldInfo.GetCustomAttribute<ReadOnly>() != null;
            var displayAsString = fieldInfo.GetCustomAttribute<DisplayAsString>() != null;

            var label = customLabel != null ? customLabel.GetText() : fieldInfo.Name;

            //Display As String
            //----------------------------------------------------------//

            if (displayAsString)
            {
                DisplayAsString(writer, label, fieldInfo);
                return;
            }

            var hasCustomEditor = fieldInfo.FieldType.HasCustomEditor();

            //Custom Editor Drawer, for non-unity objects
            //----------------------------------------------------------//
            if(hasCustomEditor && fieldInfo.FieldType.IsSubclassOf(typeof(UnityEngine.Object)) == false)
            {
                BeginFoldoutGroup(ref writer, label);
                writer.WriteLine($"<uie:PropertyField binding-path=\"{fieldInfo.Name}\" label=\"{label}\" />");
                EndFoldoutGroup(ref writer);
                return;
            }

            //Class Drawing
            //----------------------------------------------------------//

            if (fieldInfo.FieldType.IsClass)
            {
                switch (fieldInfo.FieldType.Namespace)
                {
                    case "UnityEngine":
                        writer.WriteLine( $"<uie:ObjectField binding-path=\"{fieldInfo.Name}\" label=\"{label}\" type=\"{fieldInfo.FieldType.FullName}, UnityEngine.CoreModule\" {GetReadonlyString(readOnly)}/>");
                        return;
                    default:
                        writer.WriteLine($"<uie:PropertyField binding-path=\"{fieldInfo.Name}\" label=\"{label}\" />");
                        return;
                }
            }
            //Value Type
            //----------------------------------------------------------//

            string uieType;
            switch (fieldInfo.FieldType.Name)
            {
                case nameof(Int32):
                    uieType = "IntegerField";
                    break;
                case nameof(Single):
                    uieType = "FloatField";
                    break;
                case nameof(Int64):
                    uieType = "LongField";
                    break;
                case nameof(Vector2):
                case nameof(Vector3):
                case nameof(Vector4):
                case nameof(Rect):
                case nameof(Bounds):
                case nameof(Vector2Int):
                case nameof(Vector3Int):
                    uieType = $"{fieldInfo.FieldType.Name}Field";
                    break;
                default:
                    writer.WriteLine($"<uie:PropertyField binding-path=\"{fieldInfo.Name}\" label=\"{label}\" />");
                    return;
                
            }

            //Default Return
            //----------------------------------------------------------//

            writer.WriteLine($"<uie:{uieType} label=\"{label}\" value=\"\" binding-path=\"{fieldInfo.Name}\" {GetReadonlyString(readOnly)} />");
        }

        private static void GetMethodAsUxml(in Type type, in MethodInfo methodInfo, ref UXMLWriter writer)
        {
            var button = methodInfo.GetCustomAttribute<Button>();

            if (button == null)
                return;

            s_ButtonFunctions[type].Add(methodInfo);

            var buttonText = button.GetText();

            var label = string.IsNullOrEmpty(buttonText) ? methodInfo.Name : buttonText;
            
            //FIXME Binding Path gets a string for the label, and is not the call for the method
            writer.WriteLine($"<ui:Button name=\"{methodInfo.Name}\" text=\"{label}\" display-tooltip-when-elided=\"true\" />");
        }

        //================================================================================================================//

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void BeginFoldoutGroup(ref UXMLWriter writer, in string text)
        {
            writer.WriteLine($"<ui:Foldout text=\"{text}\">");
            writer.BeginBlock();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void EndFoldoutGroup(ref UXMLWriter writer)
        {
            writer.EndBlock();
            writer.WriteLine("</ui:Foldout>");
        }

        private static void DisplayAsString(UXMLWriter writer, in string label, in FieldInfo fieldInfo)
        {
            //Example of a horizontal layout group used with 2 labels
            /*
                <ui:GroupBox style="justify-content: flex-start; flex-direction: row; align-items: auto;">
                    <ui:Label text="Label" display-tooltip-when-elided="true" />
                    <ui:Label text="Label" display-tooltip-when-elided="true" />
                </ui:GroupBox>
             */
            writer.WriteLine("<ui:GroupBox style=\"justify-content: flex-start; flex-direction: row; align-items: auto; margin-top: 1px; padding-left: 0; padding-right: 0; padding-top: 0; padding-bottom: 0;\">");
                writer.BeginBlock();
                writer.WriteLine($"<ui:Label text=\"{label}\" display-tooltip-when-elided=\"true\" />");
                writer.WriteLine($"<ui:Label text=\"\" binding-path=\"{fieldInfo.Name}\" display-tooltip-when-elided=\"true\" />");
                writer.EndBlock();
            writer.WriteLine("</ui:GroupBox>");
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static string GetReadonlyString(in bool readOnly)
        {
            return (readOnly ? "focusable=\"false\" readonly=\"true\" style=\"opacity: 0.5;\"" : string.Empty);
        }
        
        //================================================================================================================//

        
    }
}